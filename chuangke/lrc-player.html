<!DOCTYPE html>
<html>

<head>
	<meta charset="utf8">
	<title>Loading</title>
	<style>
		html{
			overflow: hidden;
		}
		body{
			margin: 0;
			text-align: center;
			position: absolute;
			top: 50%;
			left: 35px;
			right: 35px;
			font: 1.8em sans-serif;
		}
		#hr{
			margin-top: -0.5px;
			border-bottom: none;
			border-color: black;
			left: 0;
			right: 0;
			position: fixed;
		}
		#marquee{
			background-color: white;
			box-shadow: white 0 0 35px 35px;
			position: relative;
		}
		#marquee span{
			position: relative;
			z-index: 1;
			white-space: pre-wrap;
			word-wrap: break-word;
			cursor: default;
		}
	</style>
</head>

<body>
	<hr id="hr">
	<main></main>
	<video id="song" hidden></video>
	<script>
		"use strict";

		(async () => {
		const $ = (...args) => document.querySelector(...args);
		const new_element = (...args) => document.createElement(...args);

		let lrc_uri;
		let song_uri;
		try{
			[lrc_uri, song_uri] = JSON.parse(decodeURI(location.hash.slice(1)));
		}catch(error){}
		lrc_uri = lrc_uri || prompt("lrc uri:", "");
		song_uri = song_uri || prompt("song uri:", "");

		const song = $("#song");
		song.src = song_uri;

		const timeline = ((offset, source,
			$1 = ([stat, ...rest], flags, content) => [
				...(
					flags = stat.match(/\[([^\]]+)\]/ug),
					flags
					? flags.map((
						content = stat.match(/^(?:\[[^\]]+\]\s*)+(.*)$/u)[1],
						flag => [flag, content]
					))
					: []
				),
				...(rest.length > 0 ? $1(rest) : []),
			],
			$2 = (map,
				$ = ([[key, value], ...rest], match) => [
					...(
						match = key.match(/^\[(\d+):(\d+)(?:\.(\d+))?\]$/u),
						match
						? [[
							Math.max(0, offset + match[1] * 6e4 + match[2] * 1e3 + (match[3] * 10 || 0)),
							value,
						]]
						: []
					),
					...(rest.length > 0 ? $(rest) : []),
				]
			) => [...new Map([[0, ""], ...$([...map])])].sort(([a], [b]) => a - b)
		) => $2(new Map($1(source.replace(/\r?\n/g, "\r").trim().split(/(?:\s*\r)+\s*/ug)))))
		(0, await (await fetch(lrc_uri)).text());

		const n$span = (((lrcs,
			span = new_element("span"),
			$ = ([[_, content], ...rest], span,
				result = new_element("span")
			) => (
				result.innerHTML = content ? content : " ",
				span.childElementCount
				? result.innerHTML = "<br>" + result.innerHTML
				: span.hidden = true,
				result.insertBefore(span, result.firstChild),
				[
					result,
					...(rest.length > 0 ? $(rest, result) : []),
				]
			)
		) => [span, ...$(lrcs, span)])
		(timeline));

		const marquee = (marquee => (marquee.appendChild(n$span[n$span.length - 1]), marquee))(new_element("span"));
		const main = $("main");
		main.appendChild(marquee).id = "marquee";

		const span$n = (map => span => map.get(span))(new Map(n$span.map((span, n) => [span, n])));

		const $time = ((list, last, bottom, top,
			$ = (query, n1, n2,
				n = Math.floor((n2 + n1) / 2)
			) => query < list[n][0]
			? $(query, n1, n)
			: query < list[n + 1][0]
			? n
			: $(query, n + 1, n2)
		) => query => last =
			query < list[bottom][0]
			? bottom
			: query < list[top][0]
			?
				list[last][0] <= query && query < list[last + 1][0]
				? last
				: list[last + 1][0] <= query && query < list[last + 2][0]
				? last + 1
				: $(query, bottom, top)
			: top - 1)
		(timeline, 0, 0, timeline.length);



		const oncanplaythrough = () => {
			song.removeEventListener("canplaythrough", oncanplaythrough);

			const duration = song.duration * 1e3;
			timeline.push([duration]);

			let time = 0;
			let offset;
			const play = () => void (
				song.currentTime = time < duration ? time / 1e3 : 0,
				song.play()
			);
			const set_time = t => void (
				time = t,
				document.title = ((time,
					min = Math.floor(time / 6e4),
					sec = Math.floor(time % 6e4 / 1e3)
				) => min + ":" + (sec >= 10 ? "" : "0") + sec)
				(Math.min(duration, Math.max(0, duration - time)))
			);
			const set_offset = h => void (
				offset = h,
				main.style.transform = "translateY(" + -Math.floor(offset / 0.5) * 0.5 + "px)"
			);
			const update_time = time => void (
				set_time(time),

				set_offset(
					((timeline, spans, n, time,
						t = timeline[n][0],
						h1 = spans[n].offsetHeight,
						h2 = spans[n + 1].offsetHeight - h1
					) => h1 + h2 * (time - t) / (timeline[n + 1][0] - t))
					(timeline, n$span, $time(time), time))
			);
			const update_offset = offset => void (
				set_offset(offset),

				set_time(
					((n,
						t1 = timeline[n - 1][0],
						t2 = timeline[n][0],
						h1 = n$span[n - 1].offsetHeight,
						h2 = n$span[n].offsetHeight
					) => t1 + (offset - h1) * (t2 - t1) / (h2 - h1))
					(span$n(document.elementFromPoint(
						document.documentElement.clientWidth / 2,
						document.documentElement.clientHeight / 2)) || timeline.length - 1))
			);

			let animation;
			let is_playing = false;
			const onplay = () => {
				clearTimeout(animation);
				animation = setTimeout(onplay, 70);
				update_time(song.currentTime * 1e3);
			};
			song.addEventListener("play", () => {
				is_playing = true;
				onplay();
			});
			song.addEventListener("pause", () => {
				is_playing = false;
				update_time(song.currentTime * 1e3);
				clearTimeout(animation);
			});

			let status;
			let timer;
			let last_event;
			const onmousemove = () => {
				clearTimeout(timer);
				timer = null;
				if(last_event){
					const {screenX, screenY} = last_event;
					last_event = null;
					if(status){
						let [x, y, time, is_playing, yy, k, is_clicking] = status;

						const _offset = offset + (yy - screenY) / devicePixelRatio;
						update_offset(_offset < 0 ? 0 : Math.min(_offset, marquee.offsetHeight));
						if(is_clicking && (screenX - x) ** 2 + (screenY - y) ** 2 > k) is_clicking = false;

						status = [x, y, time, is_playing, screenY, k, is_clicking];
					}
				}
			};
			addEventListener("mousedown", ({button, screenX, screenY}) => {
				if(button === 0){
					status = [screenX, screenY, time, is_playing, screenY, 13 * devicePixelRatio ** 2, true];
					song.pause();
					setTimeout(() => void update_time(status[2]), 0);
				}
			});
			addEventListener("mousemove", event => {
				last_event = event;
				if(!timer){
					onmousemove();
					timer = setTimeout(onmousemove, 25);
				}
			});
			addEventListener("mouseup", ({button}) => {
				onmousemove();
				if(status && button === 0){
					const [x, y, time, is_playing, k, pr2, is_clicking] = status;
					if(is_clicking){
						update_time(time);
						if(!is_playing) play();
					}else if(is_playing){
						play();
					}
					status = null;
				}
			});

			addEventListener("resize", () => {
				if(is_playing){
					onplay();
				}else{
					update_time(time);
				}
			});

			play();
		};
		song.addEventListener("canplaythrough", oncanplaythrough);
		})();


		addEventListener("dragstart", event => {
			event.preventDefault();
		});
		addEventListener("contextmenu", () => {
			document.getSelection().removeAllRanges();
		});
		addEventListener("mousedown", event => {
			if(event.button === 0){
				event.target.focus();
				event.preventDefault();
			}
		});
		addEventListener("scroll", () => {
			scrollTo(0, 0);
		});
		addEventListener("hashchange", () => {
			location.reload();
		});
	</script>
</body>

</html>
